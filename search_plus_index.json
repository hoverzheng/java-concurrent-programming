{"./":{"url":"./","title":"Introduction","keywords":"","body":"java concurrent programming 基于java.util.concurrent包的java并发编程。主要包括以下内容： 第一部分 并发容器 第一章 锁和条件变量 Sync和Wait 显示锁 第二章 Queue ArrayBlockingQueue ConcurrentLinkedQueue DelayQueue LinkedBlockingQueue LinkedTransferQueue PriorityBlockingQueue SynchronousQueue 第三章 Map ConcurrentHashMap ConcurrentSkipListMap 第四章 Deque LinkedBlockingDeque ConcurrentLinkedDeque 第五章 Set ConcurrentSkipListSet CopyOnWriteArraySet 第六章 List CopyOnWriteArrayList 第七章 并发容器其他类 CyclicBarrier 第二部分 线程池 基本概念 ThreadPoolExecutor ScheduledThreadPoolExecutor Copyright © hoverzheng.github.io 2017 all right reserved，powered by GitbookUpdated: 2020-05-25 22:44:38 "},"LockAndSync/synchronizedAndWait.html":{"url":"LockAndSync/synchronizedAndWait.html","title":"Sync和Wait","keywords":"","body":"synchronized的原理和使用 synchronized一般语法 synchronized (expr) { statements } 注意:这里的expr的值必须是某个对象的引用。而当expr表达式为空时，其实是作用在this指针上的。 synchronized的原理 要是在某个对象上使用synchronized，那么会先获取这个对象的锁，然后执行方法体，最后释放这个对象上的锁。 注意：无论synchronized的包括的语句中发生任何异常，错误终止，对象上的锁都会被释放。有时候可以利用它的这个特性来进行设计。 注意：synchronized的锁是作用在某个对象上，要是作用在一个类的不同对象上，不同对象上的synchronized是不起作用的。 构造器在创建任何对象时，是单线程的，所以它不需要也不能被声明为synchronized。 synchronized方法和synchronized语句 synchronized方法 在方法名前面添加synchronized关键字，表示在整个方法的代码块加锁。加锁的粒度比较粗，大多数情况下并不太合适。 // 在方法中使用synchronized，将会在整个方法区加锁。 public synchronized long getBalance() { return balance; } synchronized语句 把需要同步的语句块，使用synchronized(expr){} 包括起来，实现部分语句块的加锁。使用这种方式，加锁的粒度可以根据自己的需要进行控制，比较灵活。 // 对部分代码块进行加锁 public static void doArray(int[] values) { synchronized (values) { for (int i = 0; i 静态synchronized方法 可以把synchronized添加到静态方法上，因为每个类都有与其关联的Class对象，静态同步方法就是它所属类的Class对象上的锁。 两个线程不能同时执行同一个类的静态同步方法，和两个线程不能同时在同一对象上执行同步方法一样。 注意：在静态同步方法中获取Class对象上的锁，不会对这个类的任何对象产生影响，也就是说，当一个线程在执行静态同步方法时，任然可以在这个类的对象上调用并执行该同步方法。 静态synchronized方法的锁和以下代码效果相同： class Body() { synchronized(Body.class) { idNum = nextID++; } } 使用静态synchronized的例子： package DoThread; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class DoStaticSync { public static void main(String[] args) { DoThreadPool(); } // 通过线程池来管理线程 public static void DoThreadPool() { ExecutorService executor = Executors.newFixedThreadPool(2); // 提交执行线程 executor.execute(new DoStaticSync.PrintChar()); executor.execute(new DoStaticSync.PrintNum()); executor.shutdown(); } private static class PrintChar implements Runnable { public void run() { Worker.PrintChars(); } } private static class PrintNum implements Runnable { public void run() { Worker.PrintNums(); } } // inner class: worker class private static class Worker { public final static int times = 1000; public static synchronized void PrintChars() { for (int i = 0; i 对synchronized的理解总结 首先，java中没有操作系统中的临界区、互斥量的概念，java中的原子操作是通过synchronized关键字来实现。 java的synchronized()法类似于操作系统概念中的互斥内存块，在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作 一个日本作者-结成浩的《java多线程设计模式》有这样的一个列子： pulbic class Something() { public synchronized void isSyncA(){} public synchronized void isSyncB(){} public static synchronized void cSyncA(){} public static synchronized void cSyncB(){} } 那么，若有Something类的两个实例a与b，那么下列组方法何以被1个以上线程同时访问呢 a. x.isSyncA()与x.isSyncB() b. x.isSyncA()与y.isSyncA() c. x.cSyncA()与y.cSyncB() d. x.isSyncA()与Something.cSyncA() 这里，很清楚的可以判断： a，都是对同一个实例的synchronized域访问，因此不能被同时访问 b，是针对不同实例的，因此可以同时被访问 c，因为是static synchronized，所以不同实例之间仍然会被限制,相当于Something.isSyncA()与 Something.isSyncB()了，因此不能被同时访问。 那么，第d呢?，书上的 答案是可以被同时访问的，答案理由是synchronzied的是实例方法与synchronzied的类方法由于锁定（lock）不同的原因。 因此，通过对类的方法加上synchronized来实现对该类的对象（代表共享区域）的原子操作,防止对多线程对共享数据的修改造成的不确定性，因此多线程中可以通过将要共享的数据和对数据修改的方法封装到一个类中，从而实现多线程中的并行运行，如：多线程中对同一个文件的写入操作。 wait 和 notify wait方法让一个线程等待，直到某个条件出现。 notify和notifyAll方法，通知正在等待的线程，发生了某个满足条件的事件。 这几个方法都是在Object中定义的，所有类都会继承它。 函数详细介绍 public final void notify() 通知最多一个正在等待条件发生的线程，若有多个线程会任意选择一个线程来唤醒。若不太确定唤醒满足条件的线程，应该使用notifyAll()。 public final void notifyAll() 通知所有等待条件发生变化的线程。 public final void wait() throws InterruptedException 与wait(0)类似 public final void wait(long timeout, int nanos) throws InterruptedException 更细粒度的wait方法，其超时时间是timeout和nanos的和。总时间按纳秒计算为：1000000*timeout+nanos。 标准模式 wait的标准模式： synchronized void downwhenCondition() { while (!condition) wait(); // 到这里说明条件已经满足了，可以执行满足条件的代码了 ... ... } 需要注意以下几点： 所有的操作都是在同步代码块内执行。 当调用wait()时，会原子性的释放掉对象上的锁。也就是说：调用wait时会原子性的完成两件事情：(1)挂起线程 (2)释放锁。 条件测试始终在循环中进行，注意这里是while不是if。 通知模式 通知也是在同步代码中进行的 synchronized void changeCondition() { // 改变了在条件测试中的值 notifyAll(); } 注意：notify()会唤醒一个线程，而notifyAll()会唤醒所有的等待线程。 设计时要注意的点 多个线程可能在等待同一个对象，但每个线程等待的条件不同。此时需要使用notifyAll()来唤醒所有线程，因为notify()可能唤醒不满足条件的线程。 使用notify()时的情况： 所有线程等待的是同一个条件。 至少有一个线程可以从被满足的条件中获益。 当调用Notify或notifyAll时，若没有线程等待，则该通知会被忽略。 若某个线程随后决定等待，先前的通知对它不产生任何影响。只有在wait开始后产生的通知才对等待的线程有影响。 以上代码都必须在同步代码中调用。 用wait和notify实现的生产者消费者模型 下面的代码是用wait和notify实现的多生产者和消费者模型。 package DoThread; import java.util.LinkedList; import java.util.Random; class Worker { LinkedList JobQueue = new LinkedList(); Worker() {} // consumer public class Consumer implements Runnable { String item = null; public void run() { for ( ; ; ) { synchronized (JobQueue) { System.out.println(\"cons get lock\"); while (JobQueue.size() == 0) { System.out.println(\"cons wait . release lock\"); try { JobQueue.wait(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } item = JobQueue.remove(); System.out.println(\"consumer get: \" + item); } // wait for a while try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } // producer public class Producer implements Runnable { Random r; StringBuffer sb = new StringBuffer(); Producer() { r = new Random(); } public void run() { for ( ; ; ) { System.out.println(\"producer loop \"); synchronized (JobQueue) { System.out.println(\"producer get lock\"); sb.delete(0, sb.length()); sb.append(\"\").append(r.nextInt(100)); System.out.println(\"put : \" + sb.toString()); JobQueue.add(sb.toString()); JobQueue.notifyAll(); } System.out.println(\"producer release lock\"); // wait for a while try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } // work produce public void run() { Producer p = new Producer(); Consumer c = new Consumer(); new Thread(p).start(); new Thread(p).start(); // consumer new Thread(c).start(); new Thread(c).start(); new Thread(c).start(); } } public class SyncProducerAndConsumer { public static void main(String[] args) throws InterruptedException { Worker w = new Worker(); w.run(); System.out.println(\"end main\"); Thread.currentThread().join(); } } 注意这里的synchronized语句块中使用的锁。 Copyright © hoverzheng.github.io 2017 all right reserved，powered by GitbookUpdated: 2020-05-25 22:39:45 "},"LockAndSync/ReentrantLockAndCondition.html":{"url":"LockAndSync/ReentrantLockAndCondition.html","title":"显示锁","keywords":"","body":"介绍 在java5.0以后添加了一种新的同步机制：Lock接口。Lock接口提供了一组抽象的加锁操作。与内置的加锁机制有以下不同： 无条件的 可轮训的 定时的 可中断的 所有加锁和解锁的方法都是显示的 内置锁(synchronized)的功能缺陷 为什么还需要创建显示锁呢？因为内置锁不是太灵活，有一些功能缺陷： 法中断一个正在等待获取锁的线程。 无法在请求一个锁时无限等待下去。 虽然内置锁不需要显示的解锁操作，但是他却无法实现非阻塞的加锁机制。 Lock接口 Lock接口介绍 Lock接口实现了一组抽象的加锁操作。比起synchronized，它提实现了一组更加具有可扩展性的操作。它允许更加灵活的结构，可能设置不同的属性，并且可以支持多个相关的Condition对象。 一个锁是用来控制多线程访问共享资源的工具。在一般情况下，锁是排他性的，也就是同一时候只能有一个线程访问共享资源。 有的锁也提供多个线程同时访问共享资源，比如：ReadWriteLock，他可以让多个线程同时读取共享资源。 为了保证和synchronized一样能够自动释放锁，使用Lock的一般模式是: Lock l = ...; l.lock(); try { // access the resource protected by this lock } finally { l.unlock(); } Lock接口函数 * void lock() 获取锁。 * void lockInterruptibly() 获取锁，若当前线程没有被中断。 Acquires the lock unless the current thread is interrupted. * Condition newCondition() 返回一个新的条件(Condition)对象，该对象绑定在Lock对象上。 * boolean tryLock() 若在调用时该锁是free的，则获取该锁。 * boolean tryLock(long time, TimeUnit unit) 如果在给定的等待时间内空闲，并且当前线程未被中断，则获取该锁。 * void unlock() 释放锁。 ReentrantLock锁 ReentrantLock介绍 ReentrantLock锁被成功获取锁，且没有解锁的线程拥有。 当一个线程没有拥有该锁，调用lock方法最终成功时，会返回。若线程已经拥有该锁，则该线程将会立即返回。 该锁有一个构造函数，该构造函数的参数用来指定是否接收公平调度。公平调度的意思是，若是有多个线程都在等待该锁，则等待事件最长的线程获得该锁。 使用该锁的一般形式是: class X { private final ReentrantLock lock = new ReentrantLock(); // ... public void m() { lock.lock(); // block until condition holds try { // ... method body } finally { lock.unlock() } } } 注意：一定要在finally中进行显示的释放锁，这是和内置锁synchronzied不同的地方，虽然很简单，但很容易忘记。 ReentrantLock类的主要方法 public boolean tryLock() 在调用时不被另一个线程占用时，获取该锁，并立即返回true，同时把锁的持有计数(holdCount)+1。 即使在创建该锁时，设置了一个公平策略参数，当该函数获取锁可用时，该函数也会立即返回，不管其他线程是否也在等待该锁。 如果当前线程已经获取了该锁，则持有数计数增加1，该方法返回true。 若该锁被其他线程持有，该方法立即返回false。 public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException 如果在给定的等待时间内没有被另一个线程占用并且当前线程未被中断，则获取锁。 如果此锁已设置为使用合理的排序策略，则如果其他线程正在等待锁定，则不会获取可用的锁。这与tryLock（）方法相反。如果你想要一个定时的tryLock，允许在公平的锁上进行驳船，那么将定时和非定时的形式组合在一起： if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... } protected Collection getQueuedThreads() 返回一个包含可能正在等待获取该锁的线程的集合。 因为在构建此结果时，实际的线程集可能会动态更改，所以返回的集合只是尽力而为的估计。 返回的集合的元素没有特定的顺序。 该方法旨在便于构建提供更广泛监控设施的子类。 public int getWaitQueueLength(Condition condition) 返回与此锁相关联的给定条件等待的线程数的估计。 请注意，由于超时和中断可能在任何时候发生，估计仅作为实际服务员人数的上限。 该方法设计用于监视系统状态，不用于同步控制。 protected Collection getWaitingThreads(Condition condition) 返回包含可能在与此锁相关联的给定条件下等待的线程的集合。 因为在构建此结果时，实际的线程集可能会动态更改，所以返回的集合只是尽力而为的估计。 返回的集合的元素没有特定的顺序。 该方法旨在便于构建提供更广泛的状态监测设施的子类。 public boolean hasWaiters(Condition condition) 查询是否有任何线程正在等待与此锁相关联的给定条件。 请注意，由于超时和中断可能会在任何时间发生，真正的返回并不能保证未来的信号会唤醒任何线程。 该方法主要用于监视系统状态。 public final boolean hasQueuedThread(Thread thread) 查询给定的线程是否等待获取此锁。 请注意，因为取消可能会在任何时候发生，所以真正的返回并不能保证此线程将获得此锁。 该方法主要用于监视系统状态。 ReentrantLock锁实战 一个简单的使用ReentrantLock锁的例子 package PlayReentrantLock; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.locks.ReentrantLock; /** * Created by hover. * * 说明： * 演示Reentrant的基本用法，可以看到和synchronized的效果相同。 * 这里的效果是：输出的字母或数字是连续的，没有交叉输出，说明是原子执行的。可以把锁去掉看看反面的效果。 * */ public class SimpleUse { public static ReentrantLock rtlock = new ReentrantLock(); public static void main(String[] args) { // run test method SimpleUse s = new SimpleUse(); s.testRTLock(); } private void testRTLock() { ExecutorService executor = Executors.newFixedThreadPool(3); executor.execute(new PrintChar('s', 1000)); executor.execute(new PrintNum(1000)); executor.execute(new PrintChar('b', 1000)); executor.shutdown(); } // inner class: just print char class PrintChar implements Runnable { private char aChar; private int times; PrintChar(char c, int t) { aChar = c; times = t; } public void run() { rtlock.lock(); try { for (int i = 0; i 对该程序的说明: 该程序使用了线程池的服务接口ExecutorService，该接口的原理和实现会专门有章节进行讲解。 注意加锁的地方，我们把打印一长串字符或数字的地方进行了加锁，若不加锁，会产生交叉打印数字和字母的现象，可以自己试试。 这里的锁定义是一个静态变量，在该例中，若不是静态变量也不会有问题，因为是通过主类对象运行的。 虽然输出的字母和数值都是连续的，但整体的顺序不可预知，这是由线程的调度决定的（谁先持有该锁，谁先运行）。比如： 结果可能是： sssssssssss...bbbbbbbbb...1 2 3 4...1000 也可能是: bbbbbbbbbb...sssssssss...1 2 3 4...1000 或 1 2 3 4 5 ... 1000 ...sssssssss...bbbbbbbb...bbb 对于ReentrantLock，更多的时候还是与条件变量(Condition)结合使用。 Condition Condition要点 通过将它们与使用任意锁(Lock)的实现相结合，Condition将对象监视方法 (wait, notify and notifyAll) 转换为不同的对象来给出每个对象具有多个等待集的效果。Lock替换了synchronized方法和语句，而Condition替换Object监视器方法的使用。 Condition(也称为条件变量)提供了一组方法，该组方法可以让线程阻塞（等待）直到另一个线程通知某种状态为真。 因为访问这些共享状态信息发生在不同的线程中，所以它们必须被保护，因此某种形式的锁与该条件相关联。 等待条件的关键属性是：它原子上释放相关的锁并挂起当前线程，就像Object.wait一样。 Condition对象本质上被绑定到锁，要获取Condition实例对象，先要获取Lock对象，然后使用其newCondition()方法来获取条件变量。 官方提供了一个有界buffer的例子: class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); try { while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; } finally { lock.unlock(); } } } 对于以上程序要注意： 以上程序实际上实现了一个环形缓冲区，请看以下实现： // 当保存元素的位置和buffer的长度相等，则回绕到buffer的第0个位置 if (++putptr == items.length) putptr = 0; 在放数据的时候，若数据的个数已经和buffer的长度相等，则需要等待： while (count == items.length) notFull.await(); 同理，当元素的个数为0时，取数据需要等待: while (count == 0) notEmpty.await(); 官方批注：（ArrayBlockingQueue类提供此功能，因此没有理由实现此示例使用类。） 看了一下ArrayBlockingQueue的实现（专门有章节分析），的确实现了该示例代码的逻辑。可以直接使用，这也是java比较方便的地方。 Condition设计上的考虑 这里的内容一部分来自于官方。 等待条件时，允许发生“虚假唤醒”，一般来说，作为对底层平台语义的让步。这对大多数应用程序几乎没有实际的影响，因为在循环中应始终等待条件，测试正在等待的状态谓词。一个实现可以消除虚假唤醒的可能性，但建议应用程序员总是假定它们可以发生，因此总是等待循环。 注意：虚假唤醒的意思是，await函数返回，但线程还不可运行。 Condition的主要方法 void await() 强制调用线程等待，直到它被信号通知到或被中断。调用该系列函数 boolean await(long time, TimeUnit unit) 使得当前线程等待，直到该线程被信号(signal)通知，或被终端，或指定的等待时间过去。 long awaitNanos(long nanosTimeout) 和上面的函数相同，不过这里的时间单位是纳秒。 void awaitUninterruptibly() 使得当前线程等待，直到该线程被信号(signal)通知， boolean awaitUntil(Date deadline) 使得当前线程等待，直到该线程被信号通知，或被终端，或到达指定的最后期限。 void signal() 唤醒等待线程。 void signalAll() 唤醒所有的等待线程。 各个方法的设计要点说明： 在调用await系列函数时，和该锁关联的Condition会自动释放，线程将阻塞而不能被调度使用。直到发生以下事件： 其他线程通过调用signal方法唤醒该Condition，而目前的线程正好被选中唤醒。 其他线程通过调用signalAll方法唤醒该Condition。 目前的线程被其他线程中断 发生“虚假唤醒” 在所有情况下，在此方法返回之前，当前线程必须重新获取与此条件相关联的锁。 当线程返回时，保证保持此锁。 若目前的线程，在进入该方法时设置了中断状态; 若当前线程，在等待和中止线程挂起时被中断，然后抛出InterruptedException并清除当前线程的中断状态。 在第一种情况下，没有规定在释放锁之前是否发生中断测试。 实现的考虑： 会假设在调用该方法时，已经持有与该Condition关联的锁。如果没有，可能会抛出异常。 Condition + ReentrantLock编程实战 基于环形缓冲区的多生产者消费者模型 package PlayReentrantLock; import java.util.Random; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ProductorConsumer { // task queue，这里的任务队列使用的是数组，这样不需要每次都分配内存，减少开销 private static String[] taskQueue = new String[1000]; // write and read lock private static Lock rtlock = new ReentrantLock(); private static final Condition notFull = rtlock.newCondition(); private static final Condition notEmpty = rtlock.newCondition(); // 需要记录读和写的位置 private static int gpos = 0; // get pos private static int ppos = 0; // put pos private static int count = 0; // item count private Random r = new Random(10000); public static void main(String[] args) { ProductorConsumer pc = new ProductorConsumer(); pc.workproc(); } public void workproc() { ExecutorService executor = Executors.newFixedThreadPool(3); executor.execute(new Productor()); executor.execute(new Productor()); executor.execute(new Consumer()); executor.shutdown(); } // inner class productor private class Productor implements Runnable { public void run() { for ( ; ; ) { rtlock.lock(); try { taskQueue[ppos] = Integer.toString(r.nextInt(100000)); // put item System.out.println(Thread.currentThread().toString() + \" put item: [\" + ppos + \"] = \" + taskQueue[ppos]); // 队列满了，回绕到0位置继续放数据，此时会把以前老的数据覆盖 if (++ppos == taskQueue.length) ppos = 0; count++; notEmpty.signalAll(); } finally { rtlock.unlock(); } try { Thread.sleep(r.nextInt(10)*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } // inner class consumer private class Consumer implements Runnable { public void run() { for (; ; ) { rtlock.lock(); try { while (count == 0) notEmpty.await(); System.out.println(Thread.currentThread().toString() + \" get item \" + Integer.toString(gpos) + \" \" + taskQueue[gpos]); // roll back if (++gpos == taskQueue.length) gpos = 0; --count; } catch (InterruptedException e) { e.printStackTrace(); } finally { rtlock.unlock(); } try { Thread.sleep(r.nextInt(10)*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 程序解读： 该程序使用ReentrantLock类的锁和条件变量实现了一个，多生产者和多消费者模型。 可以看到以上模型，的生产者是不会等待的，会不断的向任务队列中放任务，即使任务队列已经满了。 在生产者放任务时，若到达了队列尾部，会回绕到队列头部继续放任务。 以上模型的任务队列被设计成一个数组而不是其他可以动态增加删除节点的结构，这是出于性能的考虑。 为什么要设计成以上模型？是有考虑的： 我们设想一个场景：一个http服务器的设计，可能会通过一个线程来接收请求，并把请求放到一个内存任务队列中，并通知处理请求的线程池，处理请求的线程池接收到请求，从队列处理请求。 在这个场景中，若设计成队列满了就等待的模型，当队列满时新的请求进来会等待。而若按以上设计，则不会等待。到底使用哪一种，需要根据实际需要权很。 再则，若真的到了队列满还处理不完的情况，可能就不是单个服务能解决的，应该使用分布式服务。 基于环形缓冲区的多生产者消费者模型2 以下程序解读： 该程序和上一个模型相似，但若队列满了，该程序的模型会让生产者阻塞。这样，有些网络服务器端，就会发生请求的丢失。 为了不产生任务丢失，任务队列的size需要根据实际情况进行设计。 在以下测试中，生产者和消费者的线程个数可以任意调整，不会影响该模型的运行。 package PlayReentrantLock; import java.util.Random; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ProduceConsumerBlocking { // task queue private static String[] taskQueue = new String[1000]; // write and read lock private static Lock rtlock = new ReentrantLock(); private static final Condition notFull = rtlock.newCondition(); private static final Condition notEmpty = rtlock.newCondition(); private static int gpos = 0; // get pos private static int ppos = 0; // put pos private static int count = 0; // item count private Random r = new Random(10000); public static void main(String[] args) { ProductorConsumer pc = new ProductorConsumer(); pc.workproc(); } public void workproc() { ExecutorService executor = Executors.newFixedThreadPool(4); executor.execute(new Productor()); executor.execute(new Productor()); executor.execute(new Consumer()); executor.execute(new Consumer()); executor.shutdown(); } // inner class productor private class Productor implements Runnable { public void run() { for ( ; ; ) { rtlock.lock(); try { // 若任务队列已经满了，则等待 while (count == taskQueue.length) notFull.await(); taskQueue[ppos] = Integer.toString(r.nextInt(100000)); // put item System.out.println(Thread.currentThread().toString() + \" put item: [\" + ppos + \"] = \" + taskQueue[ppos]); // 队列满了，回绕到0位置继续放数据，此时会把以前老的数据覆盖 if (++ppos == taskQueue.length) ppos = 0; count++; // 已经放入了一个元素，发送队列不空的信号 notEmpty.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); } finally { rtlock.unlock(); } try { Thread.sleep(r.nextInt(10)*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } // inner class consumer private class Consumer implements Runnable { public void run() { for (; ; ) { rtlock.lock(); try { while (count == 0) notEmpty.await(); System.out.println(Thread.currentThread().toString() + \" get item \" + Integer.toString(gpos) + \" \" + taskQueue[gpos]); // roll back if (++gpos == taskQueue.length) gpos = 0; --count; // 已经取走了一个元素，此时发送队列已满的信号 notFull.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); } finally { rtlock.unlock(); } try { Thread.sleep(r.nextInt(10)*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 总结 ReentrantLock显示的实现了java内部的锁机制，它使得加锁更加灵活。 ReentrantLock提供公平加锁的算法，可以在需要的时候进行设置。 ReentrantLock也有一定的弊端： 在使用的时候必须要显示的解锁，并添加try{}语句块，形式如下：public void m() { lock.lock(); // block until condition holds try { // ... method body } finally { lock.unlock() } } Copyright © hoverzheng.github.io 2017 all right reserved，powered by GitbookUpdated: 2020-05-25 22:39:45 "},"IQueue/ArrayBlockingQueue.html":{"url":"IQueue/ArrayBlockingQueue.html","title":"ArrayBlockingQueue","keywords":"","body":"BlockingQueue接口 介绍 java.util.concurrent包中的Java BlockingQueue接口表示一个线程可以安全地插入并从中获取实例的队列。 BlockingQueue接口要点 支持当队列变为非空时取回元素，也支持当队列有剩余空间时往队列中存放元素。 BlockingQueue可能是容量限制的。 在任何给定的时间，它可能具有剩余容量，超过这个容量不能在没有阻塞的情况下放置其他元素。 没有任何内在容量约束的BlockingQueue总是报告Integer.MAX_VALUE的剩余容量。 BlockingQueue不接受null元素。在add，put，或offer一个空元素时，将会抛出NullPointerException异常。 使用null作为哨兵值来指示轮询操作失败。 BlockingQueue实现被设计为主要用于生产者 - 消费者队列，但另外支持Collection接口。 因此，例如，可以使用remove（x）从队列中删除任意元素。但这样的操作通常不能非常有效地执行，并且仅用于偶尔使用，诸如当排队的消息被取消时。   BlockingQueue的实现是线程安全的。所有排队方法都使用内部锁或其他形式的并发控制来实现其效果。 但是，批量Collection 操作addAll，containsAll，retainAll和removeAll不一定以原子方式执行，除非在实现中另有指定。因此，例如，在c中添加部分元素后，addAll(c)可能失败（抛出异常）。   BlockingQueue不支持严格意义上的close或shutdown操作，来表示再没有元素会添加到队列中。这些功能的需求和使用往往依赖于实现。例如，一个常见的策略是生产者插入特殊的流结尾符(end-of-stream)和位置对象，在消费者使用时会被相应地解释。   使用示例代码：基于典型的生产者-消费者场景。请注意，BlockingQueue可以安全地与多个生产者和多个消费者一起使用。   还可以访问BlockingQueue中的所有元素，而不仅仅是开始和结束处的元素。例如，假设您已排队处理对象，但是您的应用程序决定取消它。然后，您可以调用remove（o）删除队列中的特定对象。但是，这并不是非常有效，所以你不应该使用这些Collection方法，除非你真的必须 以下代码是官方的示例： class Producer implements Runnable { private final BlockingQueue queue; Producer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { queue.put(produce()); } } catch (InterruptedException ex) { ... handle ...} } Object produce() { ... } } class Consumer implements Runnable { private final BlockingQueue queue; Consumer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { consume(queue.take()); } } catch (InterruptedException ex) { ... handle ...} } void consume(Object x) { ... } } class Setup { void main() { BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 = new Consumer(q); Consumer c2 = new Consumer(q); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); } } BlockingQueue方法说明   BlockingQueue有四组不同的方法来插入，删除和检查队列中的元素。在所请求的操作无法立即执行的情况下，每组方法的行为不同。这是一个表的方法： method Throws Exception Special Value Blocks Times Out Insert add(o) offer(o) put(o) offer(o, timeout, timeunit) Remove remove(o) poll() take() poll(timeout, timeunit) Examine element() peek() 这四种不同的行为意味着： 抛出异常： 如果尝试的操作不可能立即，抛出异常。 特殊值： 如果尝试的操作不可能立即执行，则返回一个特殊值（通常为true / false）。 阻塞： 如果尝试的操作不可能immedidately，方法调用阻塞，直到它被通知。 超时： 如果尝试的操作不可能immedidately，方法调用阻塞，直到它条件满足，但不等于给定的超时。 返回一个特殊的值来告诉操作是否成功（通常为true / false）。不能将null插入到BlockingQueue中。 如果尝试插入null，BlockingQueue将抛出NullPointerException。 ArrayBlockingQueue ArrayBlockingQueue要点 是有数组实现的有界的阻塞队列。 该队列按先进先出(FIFO: first-in-first-out)排列元素。 队列的头部是队列中最老的元素，队列尾部的是队列中时间最短的元素。 新元素插入队列的尾部，队列检索操作获取队列头部的元素。 这是一个经典的“有界缓冲区”，其中固定大小的数组保存由生产者插入的元素并由消费者提取。 创建后，容量无法更改。尝试将元素放入已满的队列将导致操作阻塞;尝试从空队列中获取元素将同样阻止。 此类支持一个可选的公平策略用来对等待的生产者和消费者进行排序。 默认情况下该顺序是不保证的，但在构建队列时可以设置公平策略：所有等待线程按FIFO的顺序访队列。但公平策略可能会降低队列的性能。 ArrayBlockingQueue函数说明 boolean add(E e) 若目前的元素个数没有超过队列的容量，则可能立即把指定的元素插入到队列的尾部。 如果此队列已满，则返回true并抛出IllegalStateException。 成功返回true，失败返回false public boolean offer(E e) 该函数在队列的尾部插入指定元素，如果元素个数没有超过队列容量，可能会立即执行，成功返回true，失败返回false。 该方法通常比方法add(E)更好，因为当插入失败时add(E)只能通过抛出异常来插入元素。 public E take() 返回并删除队列的头部元素，可能会等待直到有元素可用。 ArrayBlockingQueue实现原理 类申明和变量定义 public class ArrayBlockingQueue extends AbstractQueue implements BlockingQueue, java.io.Serializable { /** * Serialization ID. This class relies on default serialization * even for the items array, which is default-serialized, even if * it is empty. Otherwise it could not be declared final, which is * necessary here. */ private static final long serialVersionUID = -817911632652898426L; /** The queued items */ // 注意：这里是Objectd的数组，也就是说队列的长度不会变化 final Object[] items; /** items index for next take, poll, peek or remove */ // 下一个读取(获取)元素的位置 int takeIndex; /** items index for next put, offer, or add */ // 下一放(写)元素的位置 int putIndex; /** Number of elements in the queue */ // 目前队列的元素个数 int count; /* * Concurrency control uses the classic two-condition algorithm * found in any textbook. */ /** Main lock guarding all access */ // 使用ReentrantLock来进行队列的同步 final ReentrantLock lock; /** Condition for waiting takes */ // 使用ReentrantLock的条件变量来进行线程间的同步 private final Condition notEmpty; /** Condition for waiting puts */ private final Condition notFull; 构造函数 public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity 说明： 阻塞队列的同步是通过ReentrantLock来实现的。 阻塞队列的线程公平调度策略是通过ReentrantLock的公平调度来实现的。 函数实现 内部函数 inc(int i)函数 该函数是一个工具函数，它会把位置参数加1，若位置到达队列尾部，回绕到队列的第一个元素的0位置。 注意：这是典型的环形缓冲区的实现方式。 /** * Circularly increment i. */ final int inc(int i) { return (++i == items.length) ? 0 : i; } private void insert(E x) 该函数向队列中添加一个元素，若到达队列的末尾直接绕回到队列的第一个位置，也就是索引为0的位置，继续放元素。 注意：该函数不会管队列是否已满，若队列已满该函数不会阻塞，会继续向putIndex写入元素。若队列的该位置已有数据，会覆盖该位置的数据。 /** * Inserts element at current put position, advances, and signals. * Call only when holding lock. */ private void insert(E x) { // 不管队列是否已满，直接把数据放入到putIndex位置，若该位置有数据，则覆盖原来位置的数据。 items[putIndex] = x; // 计算下一个放数据的位置 putIndex = inc(putIndex); // 现有元素的个数+1 ++count; // 发送notEmpty信号，通知在该条件变量上等待的线程，已经有数据放入队列。 notEmpty.signal(); } checkNotNull：空元素检查 阻塞队列的元素不能为空。 private static void checkNotNull(Object v) { if (v == null) throw new NullPointerException(); } private E extract()函数 功能： 从位置takeIndex处，取出一个元素，并把位置的数据置为null。 takeIndex的位置到达队列尾部，也会回绕到位置0。 private E extract() { final Object[] items = this.items; // 取出队列中takeIndex位置的数据 E x = this.cast(items[takeIndex]); // 数据已经取出，需要把该位置的数据重置为Null items[takeIndex] = null; // 计算下一个放数据的位置 takeIndex = inc(takeIndex); // 元素个数-1 --count; // 通知在notFull条件变量等待的线程 notFull.signal(); return x; } 对外函数 1.offer(o) 和 poll() 这两个函数提供了ArrayBlockingQueue非阻塞的操作。 public boolean offer(E e)函数 功能：该函数向队列中添加一个元素，若队列已满，直接返回false。 注意：官方文档说是向队列尾部插入一元素，从实现上来看，这个队列尾部（不是正真的队列尾），这是一个相对位置。 public boolean offer(E e) { // 检查要放入的元素e是否为空，若为空抛出异常 checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try { // 若队列中的元素个数和队列长度相等，说明队列已满，该函数直接返回false。 if (count == items.length) return false; else { // 若队列没有满，调用insert插入元素。 insert(e); return true; } } finally { // 无论如何，都要释放锁 lock.unlock(); } } public E poll()函数 若队列为空，直接返回null。 public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { return (count == 0) ? null : extract(); } finally { lock.unlock(); } } 2.put(o) 和 take() 这一对函数实现了一个经典的生产者消费者模型。队列满或队列为空时，都会阻塞等待。 public void put(E e) throws InterruptedException函数 功能：向队列中添加一个元素，若队列满了，则等待。 注意：插入的位置，也不是严格意义上的队列尾部，也是相对的。因为这是一个环形缓冲区。 public void put(E e) throws InterruptedException { // 检查要放入的元素e是否为空，若为空抛出异常 checkNotNull(e); final ReentrantLock lock = this.lock; // 这里调用方法是可中断的lock lock.lockInterruptibly(); try { // 若队列满了，则等待 while (count == items.length) notFull.await(); insert(e); } finally { lock.unlock(); } } public E take() throws InterruptedException函数 功能： 从队列中获取一个元素，若队列为空，阻塞，直到队列不为空。 要注意：这里通知的是一个线程，而不是多个。 public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { // 队列为空，等待 while (count == 0) notEmpty.await(); // 到这里说明队列已经不为空了，而且轮到该线程执行了。 return extract(); } finally { // 永远记住，锁用了要释放 lock.unlock(); } } 说明：可以看出take()和put可以配对使用。因为他们都会阻塞。他们配合使用，形成了经典的环形缓冲区的实现。 3.offer(o, timeout, timeunit) 和 poll(timeout, timeunit) public E poll(long timeout, TimeUnit unit) 在获取队列中的元素时，会先等待一会，直到超时。 public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { // 队列空 while (count == 0) { // 若等待被中断，会意外发生 if (nanos public boolean offer(E e, long timeout, TimeUnit unit) 在向队列中写数据时，会先等待一会信号，若超时则继续检查条件。 public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { // 队列满了 while (count == items.length) { // 若等待被中断 if (nanos ArrayBlockingQueue实践 以下代码是通过ArrayBlockingQueue实现的多生产者消费者模型。可以看出，由于所有的同步都有该类进行了封装，通过类实现的生产者消费者模型非常简洁。 package BlockingQueue; import java.util.Random; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; // 消费者类 class Consumer implements Runnable { private final BlockingQueue queue; Random r = new Random(1000); Consumer(BlockingQueue queue) { this.queue = queue; } public void run() { try { while (true) { String v = String.valueOf(r.nextInt(10000)); queue.put(v); System.out.println(Thread.currentThread().getName() + \" get: \" + v); Thread.sleep(r.nextInt(10)); } } catch (InterruptedException e) { e.printStackTrace(); } } } // 生产者类 class Producer implements Runnable { private final BlockingQueue queue; Random r = new Random(100000); Producer(BlockingQueue queue) { this.queue = queue; } public void run() { try { while (true) { Thread.sleep(r.nextInt(10)); String value = (String) queue.take(); System.out.println(Thread.currentThread().getName() + \" put value: \" + value); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class DoArrayBQ { public static void main(String[] args) { final BlockingQueue q = new ArrayBlockingQueue(1000); new Thread(new Producer(q)).start(); new Thread(new Producer(q)).start(); new Thread(new Consumer(q)).start(); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } } 对ArrayBlockingQueue的总结 对ArrayBlockingQueue是具有固定容量的阻塞队列。它也提供了非阻塞的操作函数，需要根据实际情况选择使用。 Copyright © hoverzheng.github.io 2017 all right reserved，powered by GitbookUpdated: 2020-05-25 22:39:45 "},"IQueue/PriorityBlockingQueue.html":{"url":"IQueue/PriorityBlockingQueue.html","title":"PriorityBlockingQueue","keywords":"","body":"PriorityBlockingQueue要点 PriorityBlockingQueue类实现了BlockingQueue接口。 PriorityBlockingQueue是一个无界并发队列。它使用与java.util.PriorityQueue类相同的排序规则。 也就是说，进入该队列的元素会自动排序，在获取该队列的元素时该队列的元素是排好序的。 不能在此队列中插入null。 虽然此队列在逻辑上是无界的，但由于资源耗尽（导致OutOfMemoryError），尝试添加可能会失败。 依靠自然排序的优先级队列也不允许插入不可比较的对象（这样做会导致ClassCastException）。 插入到PriorityBlockingQueue中的所有元素都必须实现java.lang.Comparable接口。因此，根据您在可比较实施中决定的任何优先级，这些元素将自动排序。 请注意，PriorityBlockingQueue不对具有相同优先级的元素（compare（）== 0）强制执行任何特定行为。 该类及其迭代器实现了Collection和Iterator接口的所有可选方法。 方法iterator（）中提供的迭代器不能保证以任何特定的顺序遍历PriorityBlockingQueue的元素。如果需要有序遍历，请考虑使用Arrays.sort（pq.toArray（））。 此外，方法drainTo可以用于按优先级顺序删除一些或所有元素，并将它们放在另一个集合中。 这个类的操作不会保证同等优先级的元素的顺序。若要实现同等优先级元素的顺序，需要自己实现类进行比较： 例如你要实现按fifo对元素排序的机制： 官方给出的代码如下： class FIFOEntry> implements Comparable> { static final AtomicLong seq = new AtomicLong(0); final long seqNum; final E entry; public FIFOEntry(E entry) { seqNum = seq.getAndIncrement(); this.entry = entry; } public E getEntry() { return entry; } public int compareTo(FIFOEntry other) { int res = entry.compareTo(other.entry); if (res == 0 && other.entry != this.entry) res = (seqNum 返回值 method Throws Exception Special Value Blocks Times Out Insert put(o),offer(o),add(o) Remove poll(),remove(o) take() poll(t) Examine peek() 请注意PriorityBlockingQueue的返回值情况。 由于PriorityBlockingQueue队列可以自动扩容，所以插入元素时，不用等待阻塞。 获取元素时，若队列为空，需要阻塞等待。 PriorityBlockingQueue实现原理分析 PriorityBlockingQueue使用基于数组的二叉堆，和一个公共的锁来实现。 变量定义 // 数组的默认容量大小 private static final int DEFAULT_INITIAL_CAPACITY = 11; // 数组的最大容量，源码注释：有的虚拟机可能会使用数组的头部一个字节。 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 数组，节点queue[n]的儿子节点是 queue[2*n+1]和queue[2*(n+1)]。 // 注：最小堆的定义和使用，详细见《算法导论》 private transient Object[] queue; // 队列中元素的个数 private transient int size; // 比较器，用来排序 private transient Comparator comparator; // 对操作进行同步的锁 private final ReentrantLock lock; // 基于锁的条件变量 private final Condition notEmpty; // 自旋锁，在分配新的空间时进行同步 private transient volatile int allocationSpinLock; // 优先队列变量，用来向前兼容 private PriorityQueue q; 构造函数 public PriorityBlockingQueue(int initialCapacity, Comparator comparator) 指定容量大小和对比器。该构造函数构造一个空的初始化数组的队列。 public PriorityBlockingQueue(int initialCapacity, Comparator comparator) { if (initialCapacity public PriorityBlockingQueue(Collection c) 把已有队列中的数据复制到优先队列中。需要分两种情况对集合中的数据进行处理： 若参数的结合类型是SortedSet或PriorityBlockingQueue，则不需要进行元素的调整（堆化）。 public PriorityBlockingQueue(Collection c) { this.lock = new ReentrantLock(); this.notEmpty = lock.newCondition(); boolean heapify = true; // true if not known to be in heap order boolean screen = true; // true if must screen for nulls // 若参数集合c是SortedSet类型，不需要堆化 if (c instanceof SortedSet) { SortedSet ss = (SortedSet) c; this.comparator = (Comparator) ss.comparator(); heapify = false; } else if (c instanceof PriorityBlockingQueue) { // 若是参数是PriorityBlockingQueue类型的，也不需要堆化 PriorityBlockingQueue pq = (PriorityBlockingQueue) c; this.comparator = (Comparator) pq.comparator(); screen = false; if (pq.getClass() == PriorityBlockingQueue.class) // exact match heapify = false; } // 把参数中的元素复制到Object[]数组中，然后对该数组进行堆化 Object[] a = c.toArray(); int n = a.length; // If c.toArray incorrectly doesn't return Object[], copy it. if (a.getClass() != Object[].class) a = Arrays.copyOf(a, n, Object[].class); if (screen && (n == 1 || this.comparator != null)) { for (int i = 0; i 内部函数 siftUpComparable 该函数在最小堆的位置k中插入一个元素x。 该函数用来调整最小堆中元素的位置，保证插入元素后，满足最小堆的特性。 private static void siftUpComparable(int k, T x, Object[] array) { Comparable key = (Comparable) x; while (k > 0) { // 找到父结点的位置 int parent = (k - 1) >>> 1; // 获取父结点的值 Object e = array[parent]; // 插入的值大于父节点的值，直接插入 if (key.compareTo((T) e) >= 0) break; // 否则和父节点交换，并重复这个过程，直到该节点的值大于父节点。 array[k] = e; k = parent; } array[k] = key; } private static void siftDownComparable(int k, T x, Object[] array, int n) 参数说明： k: 需要插入元素的位置 x：需要插入的元素值 array: 保存堆的数组 n：目前数组中的元素个数 功能： 把x插入到堆中。该函数会不断调整堆的结构，让所有的孩子节点的值小于父节点的值。 具体的堆调整的步骤详见《算法导论》的堆排序。 private static void siftDownComparable(int k, T x, Object[] array, int n) { if (n > 0) { Comparable key = (Comparable)x; // 数组的中间位置一定是叶子节点 int half = n >>> 1; // loop while a non-leaf while (k ) c).compareTo((T) array[right]) > 0) c = array[child = right]; // 若插入的值小于c，k应该作为父节点，否则k应该作为儿子节点 if (key.compareTo((T) c) private E dequeue() 功能说明：该函数获取堆的顶点的元素，也就是最小的元素。然后再进行堆化。 private E dequeue() { int n = size - 1; if (n cmp = comparator; if (cmp == null) siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; } } private void tryGrow(Object[] array, int oldCap) private void tryGrow(Object[] array, int oldCap) { lock.unlock(); // must release and then re-acquire main lock Object[] newArray = null; if (allocationSpinLock == 0 && UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) { try { // 分配这么多新的空间 int newCap = oldCap + ((oldCap > 1)); if (newCap - MAX_ARRAY_SIZE > 0) { // possible overflow int minCap = oldCap + 1; if (minCap MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; } if (newCap > oldCap && queue == array) newArray = new Object[newCap]; } finally { allocationSpinLock = 0; } } if (newArray == null) // back off if another thread is allocating Thread.yield(); lock.lock(); // 复制原来的数组的值到新的数组中 if (newArray != null && queue == array) { queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); } } 对外函数 public E take() throws InterruptedException 该函数获取优先队列头部的元素值，并返回 若队列为空，则阻塞等待 public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); E result; try { while ( (result = dequeue()) == null) notEmpty.await(); } finally { lock.unlock(); } return result; } public void put(E e) 该函数在向队列中插入元素时，不会阻塞或等待。因为队列的长度可以无限增加。 public void put(E e) { offer(e); // never need to block } public boolean offer(E e) 该函数向队列中添加一个值为e的元素。 若数组已满，调用tryGrow函数动态增加容量。 注意：主要扩容的代价是很大的，因为要进行数组的全部复制。 public boolean offer(E e) { if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; // 大于数组的容量，则需要扩容 while ((n = size) >= (cap = (array = queue).length)) tryGrow(array, cap); // 把元素e插入，并进行堆化 try { Comparator cmp = comparator; if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); } finally { lock.unlock(); } return true; } public boolean add(E e) 添加一个元素到优先队列中，成功返回true。失败返回false。 public boolean add(E e) { return offer(e); } public E poll() 从队列头部获取一个元素，并删除该元素。 public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { return dequeue(); } finally { lock.unlock(); } } PriorityBlockingQueue实战 生产者消费者模型 使用PriorityBlockingQueue编写的生产者消费者模型。 注意，生产者不会阻塞等待。 package BlockingQueue; import java.util.Random; import java.util.concurrent.BlockingQueue; import java.util.concurrent.PriorityBlockingQueue; class PutTask implements Runnable { private BlockingQueue queue; private Random r = new Random(1000); PutTask(BlockingQueue q) { queue = q; } public void run() { while (true) { try { Thread.sleep(2); String value = Integer.toString(r.nextInt(1000)); queue.put(value); System.out.println(Thread.currentThread().getName() + \" put value: \" + value); } catch (InterruptedException e) { e.printStackTrace(); } } } } class DealTask implements Runnable { private BlockingQueue queue; private Random r = new Random(10000); DealTask(BlockingQueue q) { queue = q; } public void run() { while (true) { try { Thread.sleep(3); String o = (String) queue.take(); System.out.println(Thread.currentThread().getName() + \" get value: \" + o); } catch (InterruptedException e) { e.printStackTrace(); } } } } public class DoPriorityBQ { public static void main(String[] args) { final BlockingQueue q = new PriorityBlockingQueue(1000); new Thread(new PutTask(q), \"producer3\").start(); new Thread(new DealTask(q), \"consumer2\").start(); new Thread(new DealTask(q), \"consumer1\").start(); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } } 测试排序功能 以下程序测试优先阻塞队列的排序功能。 package BlockingQueue; import java.util.Random; import java.util.concurrent.BlockingQueue; import java.util.concurrent.PriorityBlockingQueue; public class DoPriorityBQ2 { public static void main(String[] args) throws InterruptedException { final BlockingQueue queue = new PriorityBlockingQueue(10); Random r = new Random(100); for (int i = 0; i 程序解读： 该程序会先在队列中插入一些随机数，然后再每次取队列的头节点元素，并输出。 可以看到，输出的结果是排好序的。 该程序没有使用多线程，主要是为了测试程序的排序功能。 PriorityBlockingQueue的总结 该队列会自动对插入的元素进行排序，也就是说：在读取队列元素时，该队列已经排好序了。 PriorityBlockingQueue是使用数组实现的二叉堆，使用对排序算法实现。 由于队列会自动扩容，所以队列的写入元素方法不会等待，若应用中需要很高的并发，建议不要使用该队列，而是使用ArrayBlockingQueue。 由于队列的扩容操作代价很大 ：会申请一个新的队列，并把元素复制到新队列中，所以在实际场景中，应该预先规划好队列的荣容量大小。 该队列可能会对每个插入的元素进行堆的调整，所以时间复杂度是O(1)~O(lgn)。 Copyright © hoverzheng.github.io 2017 all right reserved，powered by GitbookUpdated: 2020-05-25 22:39:45 "},"IDeque/LinkedBlockingDeque.html":{"url":"IDeque/LinkedBlockingDeque.html","title":"LinkedBlockingDeque","keywords":"","body":"LinkedBlockingDeque要点 该队列是基于双向链表的有界阻塞队列。 构造函数的可选参数是容量的界限，用来阻止容量过度扩展的一种方法。也就是说，虽然是双向链表，但也可以指定其容量大小。 容量（如果未指定）等于Integer.MAX_VALUE。若节点数量没有到达容量的界限，链接节点在每次插入时都会动态创建。 大多数操作在恒定时间运行，异常包括remove，removeFirstOccurrence，removeLastOccurrence，contains，iterator.remove()和批量操作，所有这些都是以线性时间运行的。 可以指定元素的插入位置：头部还是尾部。 LinkedBlockingDeque实现原理 LinkedBlockingDeque类变量 以下代码是LinkedBlockingDeque的变量定义，从代码实现来看，可以得出以下要点： 创建一个Node节点，该节点有prev和next两个“指针”，所以通过该节点，可以创建一个双向链表。（具体实现看代码分析） 通过ReentrantLock锁和条件变量来进行元素访问的同步。 可以在构造LinkedBlockingDeque时指定队列的最大容量，也可以不指定，若不指定容量大小为：Integer.MAX_VALUE。 public class LinkedBlockingDeque extends AbstractQueue implements BlockingDeque, java.io.Serializable { private static final long serialVersionUID = -387911632671998426L; /** Doubly-linked list node class */ static final class Node { /** * The item, or null if this node has been removed. */ // 插入的元素不能为空 E item; /** * One of: * - the real predecessor Node * - this Node, meaning the predecessor is tail * - null, meaning there is no predecessor */ // 前一个节点的引用 Node prev; /** * One of: * - the real successor Node * - this Node, meaning the successor is head * - null, meaning there is no successor */ // 下一个节点的引用 Node next; // 为该节点赋值 Node(E x) { item = x; } } /** * Pointer to first node. * Invariant: (first == null && last == null) || * (first.prev == null && first.item != null) */ // 指向链表的头节点 transient Node first; /** * Pointer to last node. * Invariant: (first == null && last == null) || * (last.next == null && last.item != null) */ // 指向链表的尾节点 transient Node last; /** Number of items in the deque */ // 目前双向链表的元素的数量 private transient int count; /** Maximum number of items in the deque */ // 双向链表的最大元素个数 private final int capacity; /** Main lock guarding all access */ // 用来进行同步的ReentrantLock锁 final ReentrantLock lock = new ReentrantLock(); /** Condition for waiting takes */ // 基于锁的条件变量，用来判断队列是否为空 private final Condition notEmpty = lock.newCondition(); /** Condition for waiting puts */ // 基于锁的条件变量，用来判断队列是否已满 private final Condition notFull = lock.newCondition(); LinkedBlockingDeque类的构造函数 1.没有任何参数的构造函数(默认构造函数) 此时最大容量个数是Integer.MAX_VALUE。 public LinkedBlockingDeque() { this(Integer.MAX_VALUE); } 2.指定容量大小的构造函数 此时，容量大小是我们指定的大小。 public LinkedBlockingDeque(int capacity) { if (capacity 3.通过复制一个集合元素构造LinkedBlockingDeque 此时需要遍历该集合的元素，并为集合的每个元素创建一个Node，并把该Node添加到LinkedBlockingDeque中。 public LinkedBlockingDeque(Collection c) { this(Integer.MAX_VALUE); final ReentrantLock lock = this.lock; lock.lock(); // Never contended, but necessary for visibility try { // 遍历集合元素，把元素添加到LinkedBlockingDeque的尾部 for (E e : c) { if (e == null) throw new NullPointerException(); if (!linkLast(new Node(e))) throw new IllegalStateException(\"Deque full\"); } } finally { lock.unlock(); } } LinkedBlockingDeque类的内部函数 函数的返回值总结 operation Throws exception Special value Blocks Times out Insert addFirst(e) offerFirst(e) putFirst(e) offerFirst(e, time, unit) Remove removeFirst() pollFirst() takeFirst() pollFirst(time, unit) Examine getFirst() peekFirst() not applicable not applicable 基础函数 private boolean linkLast(Node node) 向队列的尾部添加一个节点：node。 目前的元素个数大于等于最大容量数，该函数直接返回false 新节点被添加到双向链表的末尾，作为末尾节点 成功后，向在条件变量notEmpty上等待的线程发送信号 /** * Links node as last element, or returns false if full. */ private boolean linkLast(Node node) { // assert lock.isHeldByCurrentThread(); // 若目前的元素个数大于等于最大容量数，直接返回false if (count >= capacity) return false; // 以下代码把新节点添加到链表末尾，新节点作为尾节点 Node l = last; node.prev = l; last = node; if (first == null) first = node; else l.next = node; ++count; // 成功把新节点放到双向链表的尾部，现在向在条件变量notEmpty上等待的线程发送信号。 notEmpty.signal(); return true; } private boolean linkFirst(Node node) 功能：在队列头部添加一个节点：node 目前的元素个数大于等于最大容量数，该函数直接返回false 新节点被添加到双向链表的头部，作为头节点 成功后，向在条件变量notEmpty上等待的线程发送信号 /** * Links node as first element, or returns false if full. */ private boolean linkFirst(Node node) { // assert lock.isHeldByCurrentThread(); // 若元素的个数超过了最大容量的限制，则返回false。 if (count >= capacity) return false; // 把新节点添加到双向链表头部，作为头节点 Node f = first; node.next = f; first = node; if (last == null) last = node; else f.prev = node; ++count; notEmpty.signal(); return true; } private E unlinkFirst() 该函数返回双线链表的第一个节点，若该节点的值。若链表为空，返回为Null。 /** * Removes and returns first element, or null if empty. */ private E unlinkFirst() { // assert lock.isHeldByCurrentThread(); Node f = first; // 链表为空，返回空 if (f == null) return null; // 获取第一个节点的值，并删除第一个节点，其中f.next=f这个操作很有java的特点。 Node n = f.next; E item = f.item; f.item = null; f.next = f; // help GC first = n; if (n == null) last = null; else n.prev = null; --count; // 头节点删除成功，向在条件变量：notFull等待的线程发送信号，通知其中的一个线程 notFull.signal(); return item; } private E unlinkLast() 功能：返回队列的最后一个节点，并删除。注意删除后，队列有可能为空。 /** * Removes and returns last element, or null if empty. */ private E unlinkLast() { // assert lock.isHeldByCurrentThread(); Node l = last; // 若队列为null，则返回空 if (l == null) return null; // 获取最后一个节点的值并删除 Node p = l.prev; E item = l.item; l.item = null; l.prev = l; // help GC last = p; if (p == null) first = null; else p.next = null; --count; // 删除后，给在条件变量notFull上等待的线程发送信号。 notFull.signal(); return item; } public boolean offerFirst(E e) 在队列头部添加一个值为e的节点。 /** * @throws NullPointerException {@inheritDoc} */ public boolean offerFirst(E e) { if (e == null) throw new NullPointerException(); Node node = new Node(e); // 使用ReentrantLock来进行加锁。 final ReentrantLock lock = this.lock; lock.lock(); try { // 向队列的头部添加节点node。 return linkFirst(node); } finally { lock.unlock(); } } public boolean offerLast(E e) 功能：在队列的尾部添加一个值为e的节点。 /** * @throws NullPointerException {@inheritDoc} */ public boolean offerLast(E e) { if (e == null) throw new NullPointerException(); Node node = new Node(e); // 使用ReentrantLock来进行加锁。 final ReentrantLock lock = this.lock; lock.lock(); try { return linkLast(node); } finally { lock.unlock(); } } 对外函数 其中的add,offer,put其实相当于，addLast,offerLast,putLast。 可以把对外接口函数分为几类进行讲解： add,addFirst,addLast 和 remove,removeFirst,removeLast 这两组方法不会阻塞，若是插入不成功，会抛出IllegalStateException异常。 public void addLast(E e) public void addLast(E e) { if (!offerLast(e)) throw new IllegalStateException(\"Deque full\"); } offer,offerFirst,offerLast 和 poll,pollFirst,pollLast 这两组函数都会返回一个值，来代表是否插入数据或获取数据成功。 实现分析 public boolean offerLast(E e) 该函数在队列的尾部添加一个值为e的节点。 该函数会先加锁，若加锁成功，直接调用linkLast把新节点插入到队列的尾部。 若队列已满(元素个数超过容量限制)，返回false，成功返回true。 注意:offer系列函数在加锁成功后不会阻塞等待。但在等待加锁时可能会因为等待锁而阻塞。public boolean offerLast(E e) { if (e == null) throw new NullPointerException(); // 生成一个新的节点 Node node = new Node(e); final ReentrantLock lock = this.lock; // 尝试加锁，这里可能阻塞 lock.lock(); try { // 加锁成功，不会阻塞，而是直接插入。成功返回true，失败返回false。 return linkLast(node); } finally { lock.unlock(); } } public E pollFirst() 该函数从队列头部获取一个节点，并删除该节点，返回该节点的值。 poll 和 pollFirst功能相同 若成功返回该节点的值，若失败返回falsepublic E pollFirst() { final ReentrantLock lock = this.lock; // 尝试加锁，这里可能会阻塞 lock.lock(); try { // 返回并删除第一个节点 return unlinkFirst(); } finally { lock.unlock(); } } put,putFirst,putLast 和 take,takeFirst,takeLast 这两组函数在放入数据或获取数据时，会判断队列是否已满，或是否为空，若是则这一组函数会等待。 实现分析 public void putLast(E e) 该函数向队列尾部添加一个值为e的节点 put 和putLast的实现相同 若队列已满，该函数会阻塞等待，直到队列有多余的空间。 public void putLast(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); Node node = new Node(e); final ReentrantLock lock = this.lock; lock.lock(); try { // 若在队列尾部添加节点失败，则在条件变量notFull上等待，直到有空位 while (!linkLast(node)) notFull.await(); } finally { lock.unlock(); } } public E takeFirst() 获取队列的第一个节点的值，并删除该节点 若队列为空，则阻塞等待 take和takeFirst功能相同 public E takeFirst() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lock(); try { E x; // 若队列为空，则阻塞等待 while ( (x = unlinkFirst()) == null) notEmpty.await(); return x; } finally { lock.unlock(); } } peek,peekFirst,peekLast和getFirst,getLast * 这一组函数只是取回队列的值，而不会删除队列的节点 * 若队列为空，getFirst,getLast会抛出异常 * 若队列为空，peek,peekFirst,peekLast会返回空 实现分析 public E peekFirst() public E peekFirst() { final ReentrantLock lock = this.lock; lock.lock(); try { // 获取第一个节点的值，但不删除节点。若第一个节点为空，返回Null return (first == null) ? null : first.item; } finally { lock.unlock(); } } public E getFirst() public E getFirst() { // 获取第一个节点的值，但不删除节点 E x = peekFirst(); // 若为空，抛出异常 if (x == null) throw new NoSuchElementException(); return x; } 栈方法：push 和 pop public void push(E e) { addFirst(e); } /** * @throws NoSuchElementException {@inheritDoc} */ public E pop() { return removeFirst(); } LinkedBlockingDeque使用实战 以下代码实例，使用LinkedBlockingDeque来实现生产者和消费者的同步。 通过该类实现的生产者和消费者模型，非常简洁。 package BlockingQueue; import java.util.Random; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingDeque; /* * 多生产者，多消费者模型，通过LinkedBlockingDeque实现。 */ // comsumer class BQConsumer implements Runnable { private final BlockingQueue queue; Random r = new Random(1000); BQConsumer(BlockingQueue queue) { this.queue = queue; } public void run() { try { while (true) { String v = String.valueOf(r.nextInt(10000)); queue.put(v); System.out.println(Thread.currentThread().getName() + \" get: \" + v); Thread.sleep(r.nextInt(10)); } } catch (InterruptedException e) { e.printStackTrace(); } } } // producer class BQProducer implements Runnable { private final BlockingQueue queue; Random r = new Random(100000); BQProducer(BlockingQueue queue) { this.queue = queue; } public void run() { try { while (true) { Thread.sleep(r.nextInt(10)); String value = (String) queue.take(); System.out.println(Thread.currentThread().getName() + \" put value: \" + value); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class DoLinkedBDeQ { public static void main(String[] args) { final BlockingQueue q = new LinkedBlockingDeque(1000); new Thread(new BQProducer(q), \"producer1\").start(); new Thread(new BQProducer(q), \"producer2\").start(); new Thread(new BQProducer(q), \"producer3\").start(); new Thread(new BQConsumer(q), \"consumer2\").start(); new Thread(new BQConsumer(q), \"consumer1\").start(); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } } LinkedBlockingDeque和ArrayBlockQueue的对比 ArrayBlockQueue的队列大小是固定的，LinkedBlockingDeque的队列大小可以固定，也可以不固定。 LinkedBlockingDeque中添加和删除节点是动态的，有内存的申请和释放，性能可能有损耗。 而ArrayBlockQueue只是把某个位置的数据置为空，队列总的容量大小不会变化，变化的队列中的元素个数。 在性能要求较高的环境下，建议使用ArrayBlockQueue。 LinkedBlockingDeque是一个双向队列，尾部或头部都可以插入或获取接节点。 Copyright © hoverzheng.github.io 2017 all right reserved，powered by GitbookUpdated: 2020-05-25 22:39:45 "},"OtherIC/CyclicBarrier.html":{"url":"OtherIC/CyclicBarrier.html","title":"CyclicBarrier","keywords":"","body":"CyclicBarrier java.util.concurrent.CyclicBarrier类是一种同步机制，它允许一组线程等待其他所有线程到达共同屏障点。CyclicBarriers在涉及固定大小的线程方的程序中非常有用，这些线程必须偶尔相互等待。CyclicBarrier被称为循环，因为它可以在等待的线程被释放之后重新使用。 换句话说，所有线程必须等待，直到所有线程到达之前，才能继续任何线程。以下是图示： 图片 - CyclicBarrier Copyright © hoverzheng.github.io 2017 all right reserved，powered by GitbookUpdated: 2020-05-25 22:39:45 "},"ThreadPool/ThreadPool-Intro.html":{"url":"ThreadPool/ThreadPool-Intro.html","title":"基本概念","keywords":"","body":"线程池简介 在线程池类ThreadPoolExecutor()源码的注释中写到了设计线程池的原因。线程池主要解决两个问题： 一方面当执行大量异步任务时候线程池能够提供较好的性能。这是因为使用线程池可以减少每个任务的调用开销（因为线程池的线程是可复用的）。 另一方面线程池提供了一种资源限制和管理的手段。比如当执行一系列任务时候对线程的管理，每个ThreadPoolExecutor也保留了一些基本的统计数据，比如当前线程池完成的任务数目。 线程池的使用 参数说明 每个线程池的创建都会设置一些参数，这些参数对于理解线程池的运作机制是非常重要的，必须要理解这些参数的用法。下面对这些参数进行说明。 各种类型的线程池都是通过：ThreadPoolExecutor来进行创建的，该类的申明如下： ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue workQueue) 参数说明； corePoolSize: 是线程池中活动线程的数量，不管他们是否是空闲的。 maximumPoolSize: 线程池中允许的最大线程数量。 keepAliveTime: 当线程数大于corePoolSize数时，空闲线程终止前等待新任务的最大时间。 TimeUnit: keepAliveTime的时间单位。 workQueue: 当任务数大于线程池的最大线程数时，会先把任务放到阻塞队列中，当线程池中有空闲线程时，会在该队列中取一个任务，并把任务放到该线程中执行。 线程池实现的总体原理 [task1]\\[task2]--->[task|task|task|task|task|task|task|task]--->[threadpool] [task3]/ taskqueue... 通过线程池来完成多线程的程序，可以减少每次都要创建一个线程的开销（因为有些线程池是一次创建多个线程），减少对线程的维护操作。 在创建线程池并向线程池中添加任务时(调用execute(Runnable task))，线程池会为每个任务创建一个线程并使用该线程来运行整个任务，当任务数大于线程池的线程个数时，会把这些任务添加到一个阻塞队列中。当线程池中的线程某个任务完成时，线程不会销毁，而是从阻塞队列中获取一个任务，并使用beforeExecute(wt, task);函数把任务挂载到这个线程上执行。这样就减少了线程创建的开销。 newFixedThreadPool线程池的使用 说明 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } 通过以上的函数实现可以看出，这种类型的线程池的corePoolSize和maximumPoolSize参数值都是nThreads。这意味着什么呢？ 意思是，在线程池中保持nThreads个活动线程，而线程池中允许的最大线程数也是nThreads。也就是说常驻线程和总线程数是相同的，这样线程运行完成后将不会被回收，因为要保持线程池中有nThreads个活动的线程。 实战 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Created by hover on 2017/11/22. */ class WorkerThread implements Runnable { private String s; public WorkerThread(String s) { this.s = s; } public void run() { System.out.println(Thread.currentThread().getName() + \" (Start) message : \" + s); processCommand(); System.out.println(Thread.currentThread().getName() + \" (End)\"); } private void processCommand() { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } } public class doFixThreadPool { public static void main(String[] args) { // 创建一个newFixedThreadPool类型的线程池 ExecutorService executor = Executors.newFixedThreadPool(5); for (int i = 0; i 实战输出分析 若编译运行以上代码，输出结果如下： pool-1-thread-1 (Start) message : 0 pool-1-thread-5 (Start) message : 4 pool-1-thread-3 (Start) message : 2 pool-1-thread-4 (Start) message : 3 pool-1-thread-2 (Start) message : 1 // 前五个任务立即执行 pool-1-thread-1 (End) // 等到其中一个任务结束，注意：线程不会结束，取一个剩下的线程使用该线程的资源。 pool-1-thread-5 (End) pool-1-thread-1 (Start) message : 5 pool-1-thread-5 (Start) message : 6 pool-1-thread-3 (End) pool-1-thread-3 (Start) message : 7 pool-1-thread-4 (End) pool-1-thread-4 (Start) message : 8 pool-1-thread-2 (End) pool-1-thread-2 (Start) message : 9 pool-1-thread-1 (End) pool-1-thread-5 (End) pool-1-thread-3 (End) pool-1-thread-4 (End) pool-1-thread-2 (End) Good Bye! 从以上输出可以看出：我们给一个newFixedThreadPool(5)的线程池10个任务，必然会有任务排队。可以看到: 前5个任务在线程启动阶段立即执行了，而后面的任务进入任务队列中。 当线程池中的线程执行完一个任务时，线程不会被销毁，线程池会从任务队列中取一个任务，并把任务交给该线程，利用该线程的资源继续执行。 线程池中始终有5个活动线程，也是最大的线程数，当所有任务都执行完成后，线程池中的线程才被全部回收。 Copyright © hoverzheng.github.io 2017 all right reserved，powered by GitbookUpdated: 2020-05-25 22:39:45 "}}