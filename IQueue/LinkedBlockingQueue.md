2.深入浅出LinkedBlockingQueue



3.基本要点

* 基于链表实现的**可以有界也可以无界**的阻塞队列。
* 在创建队列时若指定了队列的容量大小，则LinkedBlockingQueue是有界的，否则它是无界的。容量可以通过参数传递给LinkedBlockingQueue的构造函数。
* LinkedBlockingQueue对元素按FIFO（先进先出）顺序进行排序。也就是说：LinkedBlockingQueue的头结点是最早进入的最老的数据，尾结点是最后进入的最新的数据。
* 新插入的元素总是插入到队列的尾部，但获取节点的数据却总是从头节点开始查找。
* 



3.函数说明

| 接口名                              | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| void put(E e)                       | 将指定的元素插入到阻塞队列的末尾。若是有界队列，当队列满时，该操作会阻塞等待，直到队列有空余位置。 |
| E take()                            | 从队列头节点返回并删除一个元素。若该队列为空，则阻塞。直到队列中有元素。 |
| E poll(long timeout, TimeUnit unit) | 从队列头部返回并删除一个元素。和take不同的是，若队列为空，该函数不用一直阻塞，而是可以设置一个等待的时间周期来轮训。 |
| int size()                          | 返回此刻队列元素个数。直接获取count的值。                    |
| boolean offer(E e)                  | 将指定元素插入到队列的尾部，若队列未满，立即插入并返回 true；若队列已满，则立即返回 false。 |



3.使用场景和实战







3.LinkedBlockingQueue实现原理







参考：https://www.jianshu.com/p/9394b257fdde

